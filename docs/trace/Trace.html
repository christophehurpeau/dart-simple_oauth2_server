        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>Trace class / trace Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="trace" data-type="Trace">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../trace.html">trace</a> &rsaquo; <a href="../trace/Trace.html">Trace</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>Trace</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>A stack trace, comprised of a list of stack frames.</p>
<pre class="source">
class Trace implements StackTrace {
 /// The stack frames that comprise this stack trace.
 final List&lt;Frame&gt; frames;

 /// Returns a human-readable representation of [stackTrace]. If [terse] is
 /// set, this folds together multiple stack frames from the Dart core
 /// libraries, so that only the core library method directly called from user
 /// code is visible (see [Trace.terse]).
 static String format(StackTrace stackTrace, {bool terse: true}) {
   var trace = new Trace.from(stackTrace);
   if (terse) trace = trace.terse;
   return trace.toString();
 }

 /// Returns the current stack trace.
 ///
 /// By default, the first frame of this trace will be the line where
 /// [Trace.current] is called. If [level] is passed, the trace will start that
 /// many frames up instead.
 factory Trace.current([int level=0]) {
   if (level &lt; 0) {
     throw new ArgumentError("Argument [level] must be greater than or equal "
         "to 0.");
   }

   try {
     throw '';
   } catch (_, nativeTrace) {
     var trace = new Trace.from(nativeTrace);
     return new LazyTrace(() =&gt; new Trace(trace.frames.skip(level + 1)));
   }
 }

 /// Returns a new stack trace containing the same data as [trace].
 ///
 /// If [trace] is a native [StackTrace], its data will be parsed out; if it's
 /// a [Trace], it will be returned as-is.
 factory Trace.from(StackTrace trace) {
   if (trace is Trace) return trace;
   if (trace is Chain) return trace.toTrace();
   return new LazyTrace(() =&gt; new Trace.parse(trace.toString()));
 }

 /// Parses a string representation of a stack trace.
 ///
 /// [trace] should be formatted in the same way as a Dart VM or browser stack
 /// trace.
 factory Trace.parse(String trace) {
   try {
     if (trace.isEmpty) return new Trace(&lt;Frame&gt;[]);
     if (trace.contains(_v8Trace)) return new Trace.parseV8(trace);
     // Safari 6.1+ traces could be misinterpreted as Firefox traces, so we
     // check for them first.
     if (trace.contains(_safariTrace)) return new Trace.parseSafari6_1(trace);
     // Safari 6.0 traces are a superset of Firefox traces, so we parse those
     // two together.
     if (trace.contains(_firefoxTrace)) return new Trace.parseSafari6_0(trace);
     if (trace.contains(_friendlyTrace)) {
       return new Trace.parseFriendly(trace);
     }

     // Default to parsing the stack trace as a VM trace. This is also hit on
     // IE and Safari, where the stack trace is just an empty string (issue
     // 11257).
     return new Trace.parseVM(trace);
   } on FormatException catch (error) {
     throw new FormatException('${error.message}\nStack trace:\n$trace');
   }
 }

 /// Parses a string representation of a Dart VM stack trace.
 Trace.parseVM(String trace)
     : this(trace.trim().split("\n").map((line) =&gt; new Frame.parseVM(line)));

 /// Parses a string representation of a Chrome/V8 stack trace.
 Trace.parseV8(String trace)
     : this(trace.split("\n").skip(1)
         // It's possible that an Exception's description contains a line that
         // looks like a V8 trace line, which will screw this up.
         // Unfortunately, that's impossible to detect.
         .skipWhile((line) =&gt; !line.startsWith(_v8TraceLine))
         .map((line) =&gt; new Frame.parseV8(line)));

 /// Parses a string representation of an Internet Explorer stack trace.
 ///
 /// IE10+ traces look just like V8 traces. Prior to IE10, stack traces can't
 /// be retrieved.
 Trace.parseIE(String trace)
     : this.parseV8(trace);

 /// Parses a string representation of a Firefox stack trace.
 Trace.parseFirefox(String trace)
     : this(trace.trim().split("\n")
         .map((line) =&gt; new Frame.parseFirefox(line)));

 /// Parses a string representation of a Safari stack trace.
 ///
 /// This will automatically decide between [parseSafari6_0] and
 /// [parseSafari6_1] based on the contents of [trace].
 factory Trace.parseSafari(String trace) {
   if (trace.contains(_safariTrace)) return new Trace.parseSafari6_1(trace);
   return new Trace.parseSafari6_0(trace);
 }

 /// Parses a string representation of a Safari 6.1+ stack trace.
 Trace.parseSafari6_1(String trace)
     : this(trace.trim().split("\n")
         .map((line) =&gt; new Frame.parseSafari6_1(line)));

 /// Parses a string representation of a Safari 6.0 stack trace.
 ///
 /// Safari 6.0 stack traces look just like Firefox traces, except that they
 /// sometimes (e.g. in isolates) have a "[native code]" frame. We just ignore
 /// this frame to make the stack format more consistent between browsers.
 /// Prior to Safari 6.0, stack traces can't be retrieved.
 Trace.parseSafari6_0(String trace)
     : this(trace.trim().split("\n")
         .where((line) =&gt; line != '[native code]')
         .map((line) =&gt; new Frame.parseFirefox(line)));

 /// Parses this package's string representation of a stack trace.
 ///
 /// This also parses string representations of [Chain]s. They parse to the
 /// same trace that [Chain.toTrace] would return.
 Trace.parseFriendly(String trace)
     : this(trace.trim().split("\n")
         // Filter out asynchronous gaps from [Chain]s.
         .where((line) =&gt; !line.startsWith('====='))
         .map((line) =&gt; new Frame.parseFriendly(line)));

 /// Returns a new [Trace] comprised of [frames].
 Trace(Iterable&lt;Frame&gt; frames)
     : frames = new UnmodifiableListView&lt;Frame&gt;(frames.toList());

 /// Returns a VM-style [StackTrace] object.
 ///
 /// The return value's [toString] method will always return a string
 /// representation in the Dart VM's stack trace format, regardless of what
 /// platform is being used.
 StackTrace get vmTrace =&gt; new VMTrace(frames);

 /// Returns a terser version of [this].
 ///
 /// This is accomplished by folding together multiple stack frames from the
 /// core library or from this package, as in [foldFrames]. Remaining core
 /// library frames have their libraries, "-patch" suffixes, and line numbers
 /// removed.
 Trace get terse {
   return new Trace(foldFrames((frame) {
     return frame.isCore || frame.package == 'stack_trace';
   }).frames.map((frame) {
     if (!frame.isCore) return frame;
     var library = frame.library.replaceAll(_terseRegExp, '');
     return new Frame(Uri.parse(library), null, null, frame.member);
   }));
 }

 /// Returns a new [Trace] based on [this] where multiple stack frames matching
 /// [predicate] are folded together. This means that whenever there are
 /// multiple frames in a row that match [predicate], only the last one is
 /// kept.
 ///
 /// This is useful for limiting the amount of library code that appears in a
 /// stack trace by only showing user code and code that's called by user code.
 Trace foldFrames(bool predicate(frame)) {
   var newFrames = &lt;Frame&gt;[];
   for (var frame in frames.reversed) {
     if (!predicate(frame)) {
       newFrames.add(frame);
     } else if (newFrames.isEmpty || !predicate(newFrames.last)) {
       newFrames.add(new Frame(
           frame.uri, frame.line, frame.column, frame.member));
     }
   }

   return new Trace(newFrames.reversed);
 }

 /// Returns a human-readable string representation of [this].
 String toString() {
   // Figure out the longest path so we know how much to pad.
   var longest = frames.map((frame) =&gt; frame.location.length)
       .fold(0, math.max);

   // Print out the stack trace nicely formatted.
   return frames.map((frame) {
     return '${padRight(frame.location, longest)}  ${frame.member}\n';
   }).join();
 }
}
</pre>
</div>
<h3>Subclasses</h3>
<p>
<span class="type-box"><span class="icon-class"></span><a href="../lazy_trace/LazyTrace.html">LazyTrace</a></span></p>
<h3>Implements</h3>
<p>
<span class="type-box"><span class="icon-class"></span>StackTrace</span></p>
<div>
<h3>Static Methods</h3>
<div class="method"><h4 id="format">
<button class="show-code">Code</button>
String <strong>format</strong>(StackTrace stackTrace, {bool terse: true}) <a class="anchor-link" href="#format"
              title="Permalink to Trace.format">#</a></h4>
<div class="doc">
<p>Returns a human-readable representation of 
<span class="param">stackTrace</span>. If 
<span class="param">terse</span> is
set, this folds together multiple stack frames from the Dart core
libraries, so that only the core library method directly called from user
code is visible (see <a class="crossref" href="../trace/Trace.html#terse">Trace.terse</a>).</p>
<pre class="source">
static String format(StackTrace stackTrace, {bool terse: true}) {
 var trace = new Trace.from(stackTrace);
 if (terse) trace = trace.terse;
 return trace.toString();
}
</pre>
</div>
</div>
</div>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="">
<button class="show-code">Code</button>
new <strong>Trace</strong>(Iterable&lt;<a href="../frame/Frame.html">Frame</a>&gt; frames) <a class="anchor-link" href="#"
              title="Permalink to Trace.Trace">#</a></h4>
<div class="doc">
<p>Returns a new <a class="crossref" href="../trace/Trace.html">Trace</a> comprised of 
<span class="param">frames</span>.</p>
<pre class="source">
Trace(Iterable&lt;Frame&gt; frames)
   : frames = new UnmodifiableListView&lt;Frame&gt;(frames.toList());
</pre>
</div>
</div>
<div class="method"><h4 id="current">
<button class="show-code">Code</button>
factory <strong>Trace.current</strong>([int level = 0]) <a class="anchor-link" href="#current"
              title="Permalink to Trace.Trace.current">#</a></h4>
<div class="doc">
<p>Returns the current stack trace.</p>
<p>By default, the first frame of this trace will be the line where
<a class="crossref" href="../trace/Trace.html#current">Trace.current</a> is called. If 
<span class="param">level</span> is passed, the trace will start that
many frames up instead.</p>
<pre class="source">
factory Trace.current([int level=0]) {
 if (level &lt; 0) {
   throw new ArgumentError("Argument [level] must be greater than or equal "
       "to 0.");
 }

 try {
   throw '';
 } catch (_, nativeTrace) {
   var trace = new Trace.from(nativeTrace);
   return new LazyTrace(() =&gt; new Trace(trace.frames.skip(level + 1)));
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="from">
<button class="show-code">Code</button>
factory <strong>Trace.from</strong>(StackTrace trace) <a class="anchor-link" href="#from"
              title="Permalink to Trace.Trace.from">#</a></h4>
<div class="doc">
<p>Returns a new stack trace containing the same data as 
<span class="param">trace</span>.</p>
<p>If 
<span class="param">trace</span> is a native <code>StackTrace</code>, its data will be parsed out; if it's
a <a class="crossref" href="../trace/Trace.html">Trace</a>, it will be returned as-is.</p>
<pre class="source">
factory Trace.from(StackTrace trace) {
 if (trace is Trace) return trace;
 if (trace is Chain) return trace.toTrace();
 return new LazyTrace(() =&gt; new Trace.parse(trace.toString()));
}
</pre>
</div>
</div>
<div class="method"><h4 id="parse">
<button class="show-code">Code</button>
factory <strong>Trace.parse</strong>(String trace) <a class="anchor-link" href="#parse"
              title="Permalink to Trace.Trace.parse">#</a></h4>
<div class="doc">
<p>Parses a string representation of a stack trace.</p>
<p>
<span class="param">trace</span> should be formatted in the same way as a Dart VM or browser stack
trace.</p>
<pre class="source">
factory Trace.parse(String trace) {
 try {
   if (trace.isEmpty) return new Trace(&lt;Frame&gt;[]);
   if (trace.contains(_v8Trace)) return new Trace.parseV8(trace);
   // Safari 6.1+ traces could be misinterpreted as Firefox traces, so we
   // check for them first.
   if (trace.contains(_safariTrace)) return new Trace.parseSafari6_1(trace);
   // Safari 6.0 traces are a superset of Firefox traces, so we parse those
   // two together.
   if (trace.contains(_firefoxTrace)) return new Trace.parseSafari6_0(trace);
   if (trace.contains(_friendlyTrace)) {
     return new Trace.parseFriendly(trace);
   }

   // Default to parsing the stack trace as a VM trace. This is also hit on
   // IE and Safari, where the stack trace is just an empty string (issue
   // 11257).
   return new Trace.parseVM(trace);
 } on FormatException catch (error) {
   throw new FormatException('${error.message}\nStack trace:\n$trace');
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="parseFirefox">
<button class="show-code">Code</button>
new <strong>Trace.parseFirefox</strong>(String trace) <a class="anchor-link" href="#parseFirefox"
              title="Permalink to Trace.Trace.parseFirefox">#</a></h4>
<div class="doc">
<p>Parses a string representation of a Firefox stack trace.</p>
<pre class="source">
Trace.parseFirefox(String trace)
   : this(trace.trim().split("\n")
       .map((line) =&gt; new Frame.parseFirefox(line)));
</pre>
</div>
</div>
<div class="method"><h4 id="parseFriendly">
<button class="show-code">Code</button>
new <strong>Trace.parseFriendly</strong>(String trace) <a class="anchor-link" href="#parseFriendly"
              title="Permalink to Trace.Trace.parseFriendly">#</a></h4>
<div class="doc">
<p>Parses this package's string representation of a stack trace.</p>
<p>This also parses string representations of <a class="crossref" href="../stack_trace.chain/Chain.html">Chain</a>s. They parse to the
same trace that <a class="crossref" href="../stack_trace.chain/Chain.html#toTrace">Chain.toTrace</a> would return.</p>
<pre class="source">
Trace.parseFriendly(String trace)
   : this(trace.trim().split("\n")
       // Filter out asynchronous gaps from [Chain]s.
       .where((line) =&gt; !line.startsWith('====='))
       .map((line) =&gt; new Frame.parseFriendly(line)));
</pre>
</div>
</div>
<div class="method"><h4 id="parseIE">
<button class="show-code">Code</button>
new <strong>Trace.parseIE</strong>(String trace) <a class="anchor-link" href="#parseIE"
              title="Permalink to Trace.Trace.parseIE">#</a></h4>
<div class="doc">
<p>Parses a string representation of an Internet Explorer stack trace.</p>
<p>IE10+ traces look just like V8 traces. Prior to IE10, stack traces can't
be retrieved.</p>
<pre class="source">
Trace.parseIE(String trace)
   : this.parseV8(trace);
</pre>
</div>
</div>
<div class="method"><h4 id="parseSafari">
<button class="show-code">Code</button>
factory <strong>Trace.parseSafari</strong>(String trace) <a class="anchor-link" href="#parseSafari"
              title="Permalink to Trace.Trace.parseSafari">#</a></h4>
<div class="doc">
<p>Parses a string representation of a Safari stack trace.</p>
<p>This will automatically decide between <a class="crossref" href="../trace/Trace.html#parseSafari6_0">parseSafari6_0</a> and
<a class="crossref" href="../trace/Trace.html#parseSafari6_1">parseSafari6_1</a> based on the contents of 
<span class="param">trace</span>.</p>
<pre class="source">
factory Trace.parseSafari(String trace) {
 if (trace.contains(_safariTrace)) return new Trace.parseSafari6_1(trace);
 return new Trace.parseSafari6_0(trace);
}
</pre>
</div>
</div>
<div class="method"><h4 id="parseSafari6_0">
<button class="show-code">Code</button>
new <strong>Trace.parseSafari6_0</strong>(String trace) <a class="anchor-link" href="#parseSafari6_0"
              title="Permalink to Trace.Trace.parseSafari6_0">#</a></h4>
<div class="doc">
<p>Parses a string representation of a Safari 6.0 stack trace.</p>
<p>Safari 6.0 stack traces look just like Firefox traces, except that they
sometimes (e.g. in isolates) have a "<code>native code</code>" frame. We just ignore
this frame to make the stack format more consistent between browsers.
Prior to Safari 6.0, stack traces can't be retrieved.</p>
<pre class="source">
Trace.parseSafari6_0(String trace)
   : this(trace.trim().split("\n")
       .where((line) =&gt; line != '[native code]')
       .map((line) =&gt; new Frame.parseFirefox(line)));
</pre>
</div>
</div>
<div class="method"><h4 id="parseSafari6_1">
<button class="show-code">Code</button>
new <strong>Trace.parseSafari6_1</strong>(String trace) <a class="anchor-link" href="#parseSafari6_1"
              title="Permalink to Trace.Trace.parseSafari6_1">#</a></h4>
<div class="doc">
<p>Parses a string representation of a Safari 6.1+ stack trace.</p>
<pre class="source">
Trace.parseSafari6_1(String trace)
   : this(trace.trim().split("\n")
       .map((line) =&gt; new Frame.parseSafari6_1(line)));
</pre>
</div>
</div>
<div class="method"><h4 id="parseV8">
<button class="show-code">Code</button>
new <strong>Trace.parseV8</strong>(String trace) <a class="anchor-link" href="#parseV8"
              title="Permalink to Trace.Trace.parseV8">#</a></h4>
<div class="doc">
<p>Parses a string representation of a Chrome/V8 stack trace.</p>
<pre class="source">
Trace.parseV8(String trace)
   : this(trace.split("\n").skip(1)
       // It's possible that an Exception's description contains a line that
       // looks like a V8 trace line, which will screw this up.
       // Unfortunately, that's impossible to detect.
       .skipWhile((line) =&gt; !line.startsWith(_v8TraceLine))
       .map((line) =&gt; new Frame.parseV8(line)));
</pre>
</div>
</div>
<div class="method"><h4 id="parseVM">
<button class="show-code">Code</button>
new <strong>Trace.parseVM</strong>(String trace) <a class="anchor-link" href="#parseVM"
              title="Permalink to Trace.Trace.parseVM">#</a></h4>
<div class="doc">
<p>Parses a string representation of a Dart VM stack trace.</p>
<pre class="source">
Trace.parseVM(String trace)
   : this(trace.trim().split("\n").map((line) =&gt; new Frame.parseVM(line)));
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="frames">
<button class="show-code">Code</button>
final List&lt;<a href="../frame/Frame.html">Frame</a>&gt;         <strong>frames</strong> <a class="anchor-link"
            href="#frames"
            title="Permalink to Trace.frames">#</a>
        </h4>
        <div class="doc">
<p>The stack frames that comprise this stack trace.</p>
<pre class="source">
final List&lt;Frame&gt; frames
</pre>
</div>
</div>
<div class="field"><h4 id="terse">
<button class="show-code">Code</button>
final <a href="../trace/Trace.html">Trace</a>         <strong>terse</strong> <a class="anchor-link"
            href="#terse"
            title="Permalink to Trace.terse">#</a>
        </h4>
        <div class="doc">
<p>Returns a terser version of <code>this</code>.</p>
<p>This is accomplished by folding together multiple stack frames from the
core library or from this package, as in <a class="crossref" href="../trace/Trace.html#foldFrames">foldFrames</a>. Remaining core
library frames have their libraries, "-patch" suffixes, and line numbers
removed.</p>
<pre class="source">
Trace get terse {
 return new Trace(foldFrames((frame) {
   return frame.isCore || frame.package == 'stack_trace';
 }).frames.map((frame) {
   if (!frame.isCore) return frame;
   var library = frame.library.replaceAll(_terseRegExp, '');
   return new Frame(Uri.parse(library), null, null, frame.member);
 }));
}
</pre>
</div>
</div>
<div class="field"><h4 id="vmTrace">
<button class="show-code">Code</button>
final StackTrace         <strong>vmTrace</strong> <a class="anchor-link"
            href="#vmTrace"
            title="Permalink to Trace.vmTrace">#</a>
        </h4>
        <div class="doc">
<p>Returns a VM-style <code>StackTrace</code> object.</p>
<p>The return value's <a class="crossref" href="../trace/Trace.html#toString">toString</a> method will always return a string
representation in the Dart VM's stack trace format, regardless of what
platform is being used.</p>
<pre class="source">
StackTrace get vmTrace =&gt; new VMTrace(frames);
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="foldFrames">
<button class="show-code">Code</button>
<a href="../trace/Trace.html">Trace</a> <strong>foldFrames</strong>(bool predicate(frame)) <a class="anchor-link" href="#foldFrames"
              title="Permalink to Trace.foldFrames">#</a></h4>
<div class="doc">
<p>Returns a new <a class="crossref" href="../trace/Trace.html">Trace</a> based on <code>this</code> where multiple stack frames matching

<span class="param">predicate</span> are folded together. This means that whenever there are
multiple frames in a row that match 
<span class="param">predicate</span>, only the last one is
kept.</p>
<p>This is useful for limiting the amount of library code that appears in a
stack trace by only showing user code and code that's called by user code.</p>
<pre class="source">
Trace foldFrames(bool predicate(frame)) {
 var newFrames = &lt;Frame&gt;[];
 for (var frame in frames.reversed) {
   if (!predicate(frame)) {
     newFrames.add(frame);
   } else if (newFrames.isEmpty || !predicate(newFrames.last)) {
     newFrames.add(new Frame(
         frame.uri, frame.line, frame.column, frame.member));
   }
 }

 return new Trace(newFrames.reversed);
}
</pre>
</div>
</div>
<div class="method"><h4 id="toString">
<button class="show-code">Code</button>
String <strong>toString</strong>() <a class="anchor-link" href="#toString"
              title="Permalink to Trace.toString">#</a></h4>
<div class="doc">
<p>Returns a human-readable string representation of <code>this</code>.</p>
<pre class="source">
String toString() {
 // Figure out the longest path so we know how much to pad.
 var longest = frames.map((frame) =&gt; frame.location.length)
     .fold(0, math.max);

 // Print out the stack trace nicely formatted.
 return frames.map((frame) {
   return '${padRight(frame.location, longest)}  ${frame.member}\n';
 }).join();
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          <div>This page was generated at 2014-02-10 17:44:11.014</div>
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
