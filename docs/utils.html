        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>utils Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="favicon.ico">
        
        </head>
        <body data-library="utils">
        <div class="page">
        <div class="header">
          <a href="index.html"><div class="logo"></div></a>
          <a href="index.html">Dart Documentation</a>
         &rsaquo; <a href="utils.html">utils</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
<h2><strong>utils</strong> library</h2>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="async">
<button class="show-code">Code</button>
final Future         <strong>async</strong> <a class="anchor-link"
            href="#async"
            title="Permalink to async">#</a>
        </h4>
        <div class="doc">
<p>Returns a <code>Future</code> that asynchronously completes to <code>null</code>.</p>
<pre class="source">
Future get async =&gt; new Future.value();
</pre>
</div>
</div>
<div class="field"><h4 id="emptyStream">
<button class="show-code">Code</button>
final Stream         <strong>emptyStream</strong> <a class="anchor-link"
            href="#emptyStream"
            title="Permalink to emptyStream">#</a>
        </h4>
        <div class="doc">
<p>Returns a closed <code>Stream</code> with no elements.</p>
<pre class="source">
Stream get emptyStream =&gt; streamFromIterable([]);
</pre>
</div>
</div>
</div>
<div>
<h3>Functions</h3>
<div class="method"><h4 id="syncFuture">
<button class="show-code">Code</button>
Future <strong>syncFuture</strong>(callback()) <a class="anchor-link" href="#syncFuture"
              title="Permalink to syncFuture">#</a></h4>
<div class="doc">
<p>Like <code>Future.sync</code>, but wraps the Future in <a class="crossref" href="stack_trace.chain/Chain.html#track">Chain.track</a> as well.</p>
<pre class="source">
Future syncFuture(callback()) =&gt; Chain.track(new Future.sync(callback));
</pre>
</div>
</div>
<div class="method"><h4 id="chainToCompleter">
<button class="show-code">Code</button>
void <strong>chainToCompleter</strong>(Future future, Completer completer) <a class="anchor-link" href="#chainToCompleter"
              title="Permalink to chainToCompleter">#</a></h4>
<div class="doc">
<p>Configures 
<span class="param">future</span> so that its result (success or exception) is passed on
to 
<span class="param">completer</span>.</p>
<pre class="source">
void chainToCompleter(Future future, Completer completer) {
 future.then(completer.complete, onError: completer.completeError);
}
</pre>
</div>
</div>
<div class="method"><h4 id="tee">
<button class="show-code">Code</button>
<a href="utils/Pair.html">Pair</a>&lt;Stream, Stream&gt; <strong>tee</strong>(Stream stream) <a class="anchor-link" href="#tee"
              title="Permalink to tee">#</a></h4>
<div class="doc">
<p>Creates two single-subscription <code>Stream</code>s that each emit all values and
errors from 
<span class="param">stream</span>. This is useful if 
<span class="param">stream</span> is single-subscription but
multiple subscribers are necessary.</p>
<pre class="source">
Pair&lt;Stream, Stream&gt; tee(Stream stream) {
 var controller1 = new StreamController(sync: true);
 var controller2 = new StreamController(sync: true);
 stream.listen((value) {
   controller1.add(value);
   controller2.add(value);
 }, onError: (error, [StackTrace stackTrace]) {
   controller1.addError(error, stackTrace);
   controller2.addError(error, stackTrace);
 }, onDone: () {
   controller1.close();
   controller2.close();
 });
 return new Pair&lt;Stream, Stream&gt;(controller1.stream, controller2.stream);
}
</pre>
</div>
</div>
<div class="method"><h4 id="streamFromIterable">
<button class="show-code">Code</button>
Stream <strong>streamFromIterable</strong>(Iterable iter) <a class="anchor-link" href="#streamFromIterable"
              title="Permalink to streamFromIterable">#</a></h4>
<div class="doc">
<p>Creates a single-subscription stream that emits the items in 
<span class="param">iter</span> and then
ends.</p>
<pre class="source">
Stream streamFromIterable(Iterable iter) {
 var controller = new StreamController(sync: true);
 iter.forEach(controller.add);
 controller.close();
 return controller.stream;
}
</pre>
</div>
</div>
<div class="method"><h4 id="writeStreamToSink">
<button class="show-code">Code</button>
Future <strong>writeStreamToSink</strong>(Stream stream, EventSink sink) <a class="anchor-link" href="#writeStreamToSink"
              title="Permalink to writeStreamToSink">#</a></h4>
<div class="doc">
<p>Pipes all data and errors from 
<span class="param">stream</span> into 
<span class="param">sink</span>. Completes <code>Future</code> once

<span class="param">stream</span> is done. Unlike <a class="crossref" href="utils.html#store">store</a>, 
<span class="param">sink</span> remains open after 
<span class="param">stream</span> is
done.</p>
<pre class="source">
Future writeStreamToSink(Stream stream, EventSink sink) {
 var completer = new Completer();
 stream.listen(sink.add,
     onError: sink.addError,
     onDone: () =&gt; completer.complete());
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="store">
<button class="show-code">Code</button>
Future <strong>store</strong>(Stream stream, EventSink sink) <a class="anchor-link" href="#store"
              title="Permalink to store">#</a></h4>
<div class="doc">
<p>Pipes all data and errors from 
<span class="param">stream</span> into 
<span class="param">sink</span>. When 
<span class="param">stream</span> is done,

<span class="param">sink</span> is closed and the returned <code>Future</code> is completed.</p>
<pre class="source">
Future store(Stream stream, EventSink sink) {
 var completer = new Completer();
 stream.listen(sink.add,
     onError: sink.addError,
     onDone: () {
       sink.close();
       completer.complete();
     });
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="onDone">
<button class="show-code">Code</button>
Stream <strong>onDone</strong>(Stream stream, void onDone()) <a class="anchor-link" href="#onDone"
              title="Permalink to onDone">#</a></h4>
<div class="doc">
<p>Calls 
<span class="param">onDone</span> once 
<span class="param">stream</span> (a single-subscription <code>Stream</code>) is finished.
The return value, also a single-subscription <code>Stream</code> should be used in
place of 
<span class="param">stream</span> after calling this method.</p>
<pre class="source">
Stream onDone(Stream stream, void onDone()) {
 var pair = tee(stream);
 pair.first.listen((_) {}, onError: (_) {}, onDone: onDone);
 return pair.last;
}
</pre>
</div>
</div>
<div class="method"><h4 id="toByteStream">
<button class="show-code">Code</button>
<a href="byte_stream/ByteStream.html">ByteStream</a> <strong>toByteStream</strong>(Stream&lt;List&lt;int&gt;&gt; stream) <a class="anchor-link" href="#toByteStream"
              title="Permalink to toByteStream">#</a></h4>
<div class="doc">
<p>If 
<span class="param">stream</span> is already a <a class="crossref" href="byte_stream/ByteStream.html">ByteStream</a>, returns it. Otherwise, wraps it in a
<a class="crossref" href="byte_stream/ByteStream.html">ByteStream</a>.</p>
<pre class="source">
ByteStream toByteStream(Stream&lt;List&lt;int&gt;&gt; stream) {
 if (stream is ByteStream) return stream;
 return new ByteStream(stream);
}
</pre>
</div>
</div>
<div class="method"><h4 id="toUint8List">
<button class="show-code">Code</button>
Uint8List <strong>toUint8List</strong>(List&lt;int&gt; input) <a class="anchor-link" href="#toUint8List"
              title="Permalink to toUint8List">#</a></h4>
<div class="doc">
<p>Converts 
<span class="param">input</span> into a <code>Uint8List</code>.</p>
<p>If 
<span class="param">input</span> is a <code>TypedData</code>, this just returns a view on 
<span class="param">input</span>.</p>
<pre class="source">
Uint8List toUint8List(List&lt;int&gt; input) {
 if (input is Uint8List) return input;
 if (input is TypedData) {
   // TODO(nweiz): remove "as" when issue 11080 is fixed.
   return new Uint8List.view((input as TypedData).buffer);
 }
 return new Uint8List.fromList(input);
}
</pre>
</div>
</div>
<div class="method"><h4 id="isPlainAscii">
<button class="show-code">Code</button>
bool <strong>isPlainAscii</strong>(String string) <a class="anchor-link" href="#isPlainAscii"
              title="Permalink to isPlainAscii">#</a></h4>
<div class="doc">
<p>Returns whether 
<span class="param">string</span> is composed entirely of ASCII-compatible
characters.</p>
<pre class="source">
bool isPlainAscii(String string) =&gt; _ASCII_ONLY.hasMatch(string);
</pre>
</div>
</div>
<div class="method"><h4 id="requiredEncodingForCharset">
<button class="show-code">Code</button>
Encoding <strong>requiredEncodingForCharset</strong>(String charset) <a class="anchor-link" href="#requiredEncodingForCharset"
              title="Permalink to requiredEncodingForCharset">#</a></h4>
<div class="doc">
<p>Returns the <code>Encoding</code> that corresponds to 
<span class="param">charset</span>. Throws a
<code>FormatException</code> if no <code>Encoding</code> was found that corresponds to 
<span class="param">charset</span>.

<span class="param">charset</span> may not be null.</p>
<pre class="source">
Encoding requiredEncodingForCharset(String charset) {
 var encoding = Encoding.getByName(charset);
 if (encoding != null) return encoding;
 throw new FormatException('Unsupported encoding "$charset".');
}
</pre>
</div>
</div>
<div class="method"><h4 id="encodingForCharset">
<button class="show-code">Code</button>
Encoding <strong>encodingForCharset</strong>(String charset, [Encoding fallback = LATIN1]) <a class="anchor-link" href="#encodingForCharset"
              title="Permalink to encodingForCharset">#</a></h4>
<div class="doc">
<p>Returns the <code>Encoding</code> that corresponds to 
<span class="param">charset</span>. Returns 
<span class="param">fallback</span> if

<span class="param">charset</span> is null or if no <code>Encoding</code> was found that corresponds to

<span class="param">charset</span>.</p>
<pre class="source">
Encoding encodingForCharset(
   String charset, [Encoding fallback = LATIN1]) {
 if (charset == null) return fallback;
 var encoding = Encoding.getByName(charset);
 return encoding == null ? fallback : encoding;
}
</pre>
</div>
</div>
<div class="method"><h4 id="split1">
<button class="show-code">Code</button>
List&lt;String&gt; <strong>split1</strong>(String toSplit, String pattern) <a class="anchor-link" href="#split1"
              title="Permalink to split1">#</a></h4>
<div class="doc">
<p>Like <code>String.split</code>, but only splits on the first occurrence of the pattern.
This will always return an array of two elements or fewer.</p>
<pre><code>split1("foo,bar,baz", ","); //=&gt; ["foo", "bar,baz"]
split1("foo", ","); //=&gt; ["foo"]
split1("", ","); //=&gt; []
</code></pre>
<pre class="source">
List&lt;String&gt; split1(String toSplit, String pattern) {
 if (toSplit.isEmpty) return &lt;String&gt;[];

 var index = toSplit.indexOf(pattern);
 if (index == -1) return [toSplit];
 return [
   toSplit.substring(0, index),
   toSplit.substring(index + pattern.length)
 ];
}
</pre>
</div>
</div>
<div class="method"><h4 id="mapToQuery">
<button class="show-code">Code</button>
String <strong>mapToQuery</strong>(Map&lt;String, String&gt; map, {Encoding encoding}) <a class="anchor-link" href="#mapToQuery"
              title="Permalink to mapToQuery">#</a></h4>
<div class="doc">
<p>Converts a <code>Map</code> from parameter names to values to a URL query string.</p>
<pre><code>mapToQuery({"foo": "bar", "baz": "bang"});
//=&gt; "foo=bar&amp;baz=bang"
</code></pre>
<pre class="source">
String mapToQuery(Map&lt;String, String&gt; map, {Encoding encoding}) {
 var pairs = &lt;List&lt;String&gt;&gt;[];
 map.forEach((key, value) =&gt;
     pairs.add([Uri.encodeQueryComponent(key, encoding: encoding),
                Uri.encodeQueryComponent(value, encoding: encoding)]));
 return pairs.map((pair) =&gt; "${pair[0]}=${pair[1]}").join("&amp;");
}
</pre>
</div>
</div>
<div class="method"><h4 id="queryToMap">
<button class="show-code">Code</button>
Map&lt;String, String&gt; <strong>queryToMap</strong>(String queryList, {Encoding encoding}) <a class="anchor-link" href="#queryToMap"
              title="Permalink to queryToMap">#</a></h4>
<div class="doc">
<p>Converts a URL query string (or <code>application/x-www-form-urlencoded</code> body)
into a <code>Map</code> from parameter names to values.</p>
<pre><code>queryToMap("foo=bar&amp;baz=bang&amp;qux");
//=&gt; {"foo": "bar", "baz": "bang", "qux": ""}
</code></pre>
<pre class="source">
Map&lt;String, String&gt; queryToMap(String queryList, {Encoding encoding}) {
 var map = {};
 for (var pair in queryList.split("&amp;")) {
   var split = split1(pair, "=");
   if (split.isEmpty) continue;
   var key = Uri.decodeQueryComponent(split[0], encoding: encoding);
   var value = Uri.decodeQueryComponent(split.length &gt; 1 ? split[1] : "",
       encoding: encoding);
   map[key] = value;
 }
 return map;
}
</pre>
</div>
</div>
</div>
<div>
<h3>Classes</h3>
          <div class="type">
          <h4>
            <a href="utils/Pair.html"><strong>Pair&lt;E, F&gt;</strong></a>
          </h4>
          </div>
          
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          <div>This page was generated at 2014-02-10 17:44:11.044</div>
        </div>
        <script async src="client-live-nav.js"></script>
        </body></html>
        
