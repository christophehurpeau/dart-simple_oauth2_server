        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>Frame class / frame Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="frame" data-type="Frame">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../frame.html">frame</a> &rsaquo; <a href="../frame/Frame.html">Frame</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>Frame</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>A single stack frame. Each frame points to a precise location in Dart code.</p>
<pre class="source">
class Frame {
 /// The URI of the file in which the code is located.
 ///
 /// This URI will usually have the scheme `dart`, `file`, `http`, or `https`.
 final Uri uri;

 /// The line number on which the code location is located.
 ///
 /// This can be null, indicating that the line number is unknown or
 /// unimportant.
 final int line;

 /// The column number of the code location.
 ///
 /// This can be null, indicating that the column number is unknown or
 /// unimportant.
 final int column;

 /// The name of the member in which the code location occurs.
 ///
 /// Anonymous closures are represented as `&lt;fn&gt;` in this member string.
 final String member;

 /// Whether this stack frame comes from the Dart core libraries.
 bool get isCore =&gt; uri.scheme == 'dart';

 /// Returns a human-friendly description of the library that this stack frame
 /// comes from.
 ///
 /// This will usually be the string form of [uri], but a relative URI will be
 /// used if possible.
 String get library {
   if (uri.scheme != Uri.base.scheme) return uri.toString();
   if (path.style == path.Style.url) return path.relative(uri.toString());
   return path.relative(path.fromUri(uri));
 }

 /// Returns the name of the package this stack frame comes from, or `null` if
 /// this stack frame doesn't come from a `package:` URL.
 String get package {
   if (uri.scheme != 'package') return null;
   return uri.path.split('/').first;
 }

 /// A human-friendly description of the code location.
 String get location {
   if (line == null) return library;
   if (column == null) return '$library $line';
   return '$library $line:$column';
 }

 /// Returns a single frame of the current stack.
 ///
 /// By default, this will return the frame above the current method. If
 /// [level] is `0`, it will return the current method's frame; if [level] is
 /// higher than `1`, it will return higher frames.
 factory Frame.caller([int level=1]) {
   if (level &lt; 0) {
     throw new ArgumentError("Argument [level] must be greater than or equal "
         "to 0.");
   }

   return new Trace.current(level + 1).frames.first;
 }

 /// Parses a string representation of a Dart VM stack frame.
 factory Frame.parseVM(String frame) {
   // The VM sometimes folds multiple stack frames together and replaces them
   // with "...".
   if (frame == '...') {
     return new Frame(new Uri(), null, null, '...');
   }

   var match = _vmFrame.firstMatch(frame);
   if (match == null) {
     throw new FormatException("Couldn't parse VM stack trace line '$frame'.");
   }

   // Get the pieces out of the regexp match. Function, URI and line should
   // always be found. The column is optional.
   var member = match[1].replaceAll("&lt;anonymous closure&gt;", "&lt;fn&gt;");
   var uri = Uri.parse(match[2]);
   // Work around issue 11901.
   if (uri == new Uri(path: 'timer_impl.dart')) {
     uri = Uri.parse('dart:async/timer_impl.dart');
   }
   var line = int.parse(match[3]);
   var column = null;
   var columnMatch = match[4];
   if (columnMatch != null) {
     column = int.parse(columnMatch);
   }
   return new Frame(uri, line, column, member);
 }

 /// Parses a string representation of a Chrome/V8 stack frame.
 factory Frame.parseV8(String frame) {
   var match = _v8Frame.firstMatch(frame);
   if (match == null) {
     throw new FormatException("Couldn't parse V8 stack trace line '$frame'.");
   }

   // V8 stack frames can be in two forms.
   if (match[2] != null) {
     // The first form looks like " at FUNCTION (PATH:LINE:COL)". PATH is
     // usually an absolute URL, but it can be a path if the stack frame came
     // from d8.
     var uri = _uriOrPathToUri(match[2]);
     var member = match[1].replaceAll("&lt;anonymous&gt;", "&lt;fn&gt;");
     return new Frame(uri, int.parse(match[3]), int.parse(match[4]), member);
   } else {
     // The second form looks like " at PATH:LINE:COL", and is used for
     // anonymous functions. PATH is usually an absolute URL, but it can be a
     // path if the stack frame came from d8.
     var uri = _uriOrPathToUri(match[5]);
     return new Frame(uri, int.parse(match[6]), int.parse(match[7]), "&lt;fn&gt;");
   }
 }

 /// Parses a string representation of an IE stack frame.
 ///
 /// IE10+ frames look just like V8 frames. Prior to IE10, stack traces can't
 /// be retrieved.
 factory Frame.parseIE(String frame) =&gt; new Frame.parseV8(frame);

 /// Parses a string representation of a Firefox stack frame.
 factory Frame.parseFirefox(String frame) {
   var match = _firefoxFrame.firstMatch(frame);
   if (match == null) {
     throw new FormatException(
         "Couldn't parse Firefox stack trace line '$frame'.");
   }

   // Normally this is a URI, but in a jsshell trace it can be a path.
   var uri = _uriOrPathToUri(match[3]);
   var member = match[1];
   member += new List.filled('/'.allMatches(match[2]).length, ".&lt;fn&gt;").join();
   if (member == '') member = '&lt;fn&gt;';

   // Some Firefox members have initial dots. We remove them for consistency
   // with other platforms.
   member = member.replaceFirst(_initialDot, '');
   return new Frame(uri, int.parse(match[4]), null, member);
 }

 /// Parses a string representation of a Safari 6.0 stack frame.
 ///
 /// Safari 6.0 frames look just like Firefox frames. Prior to Safari 6.0,
 /// stack traces can't be retrieved.
 factory Frame.parseSafari6_0(String frame) =&gt; new Frame.parseFirefox(frame);

 /// Parses a string representation of a Safari 6.1+ stack frame.
 factory Frame.parseSafari6_1(String frame) {
   var match = _safariFrame.firstMatch(frame);
   if (match == null) {
     throw new FormatException(
         "Couldn't parse Safari stack trace line '$frame'.");
   }

   var uri = Uri.parse(match[2]);
   var member = match[1];
   if (member == null) member = '&lt;fn&gt;';
   var line = match[3] == '' ? null : int.parse(match[3]);
   var column = match[4] == '' ? null : int.parse(match[4]);
   return new Frame(uri, line, column, member);
 }

 /// Parses this package's string representation of a stack frame.
 factory Frame.parseFriendly(String frame) {
   var match = _friendlyFrame.firstMatch(frame);
   if (match == null) {
     throw new FormatException(
         "Couldn't parse package:stack_trace stack trace line '$frame'.");
   }

   var uri = Uri.parse(match[1]);
   // If there's no scheme, this is a relative URI. We should interpret it as
   // relative to the current working directory.
   if (uri.scheme == '') {
     uri = path.toUri(path.absolute(path.fromUri(uri)));
   }

   var line = match[2] == null ? null : int.parse(match[2]);
   var column = match[3] == null ? null : int.parse(match[3]);
   return new Frame(uri, line, column, match[4]);
 }

 /// A regular expression matching an absolute URI.
 static final _uriRegExp = new RegExp(r'^[a-zA-Z][-+.a-zA-Z\d]*://');

 /// A regular expression matching a Windows path.
 static final _windowsRegExp = new RegExp(r'^([a-zA-Z]:[\\/]|\\\\)');

 /// Converts [uriOrPath], which can be a URI, a Windows path, or a Posix path,
 /// to a URI (absolute if possible).
 static Uri _uriOrPathToUri(String uriOrPath) {
   if (uriOrPath.contains(_uriRegExp)) {
     return Uri.parse(uriOrPath);
   } else if (uriOrPath.contains(_windowsRegExp)) {
     return new Uri.file(uriOrPath, windows: true);
   } else if (uriOrPath.startsWith('/')) {
     return new Uri.file(uriOrPath, windows: false);
   }

   // As far as I've seen, Firefox and V8 both always report absolute paths in
   // their stack frames. However, if we do get a relative path, we should
   // handle it gracefully.
   if (uriOrPath.contains('\\')) return path.windows.toUri(uriOrPath);
   return Uri.parse(uriOrPath);
 }

 Frame(this.uri, this.line, this.column, this.member);

 String toString() =&gt; '$location in $member';
}
</pre>
</div>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="">
<button class="show-code">Code</button>
new <strong>Frame</strong>(Uri uri, int line, int column, String member) <a class="anchor-link" href="#"
              title="Permalink to Frame.Frame">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Creates a new <code>Object</code> instance.</p>
<p><code>Object</code> instances have no meaningful state, and are only useful
through their identity. An <code>Object</code> instance is equal to itself
only.</p>
<div class="docs-inherited-from">docs inherited from Object </div></div>
<pre class="source">
Frame(this.uri, this.line, this.column, this.member);
</pre>
</div>
</div>
<div class="method"><h4 id="caller">
<button class="show-code">Code</button>
factory <strong>Frame.caller</strong>([int level = 1]) <a class="anchor-link" href="#caller"
              title="Permalink to Frame.Frame.caller">#</a></h4>
<div class="doc">
<p>Returns a single frame of the current stack.</p>
<p>By default, this will return the frame above the current method. If

<span class="param">level</span> is <code>0</code>, it will return the current method's frame; if 
<span class="param">level</span> is
higher than <code>1</code>, it will return higher frames.</p>
<pre class="source">
factory Frame.caller([int level=1]) {
 if (level &lt; 0) {
   throw new ArgumentError("Argument [level] must be greater than or equal "
       "to 0.");
 }

 return new Trace.current(level + 1).frames.first;
}
</pre>
</div>
</div>
<div class="method"><h4 id="parseFirefox">
<button class="show-code">Code</button>
factory <strong>Frame.parseFirefox</strong>(String frame) <a class="anchor-link" href="#parseFirefox"
              title="Permalink to Frame.Frame.parseFirefox">#</a></h4>
<div class="doc">
<p>Parses a string representation of a Firefox stack frame.</p>
<pre class="source">
factory Frame.parseFirefox(String frame) {
 var match = _firefoxFrame.firstMatch(frame);
 if (match == null) {
   throw new FormatException(
       "Couldn't parse Firefox stack trace line '$frame'.");
 }

 // Normally this is a URI, but in a jsshell trace it can be a path.
 var uri = _uriOrPathToUri(match[3]);
 var member = match[1];
 member += new List.filled('/'.allMatches(match[2]).length, ".&lt;fn&gt;").join();
 if (member == '') member = '&lt;fn&gt;';

 // Some Firefox members have initial dots. We remove them for consistency
 // with other platforms.
 member = member.replaceFirst(_initialDot, '');
 return new Frame(uri, int.parse(match[4]), null, member);
}
</pre>
</div>
</div>
<div class="method"><h4 id="parseFriendly">
<button class="show-code">Code</button>
factory <strong>Frame.parseFriendly</strong>(String frame) <a class="anchor-link" href="#parseFriendly"
              title="Permalink to Frame.Frame.parseFriendly">#</a></h4>
<div class="doc">
<p>Parses this package's string representation of a stack frame.</p>
<pre class="source">
factory Frame.parseFriendly(String frame) {
 var match = _friendlyFrame.firstMatch(frame);
 if (match == null) {
   throw new FormatException(
       "Couldn't parse package:stack_trace stack trace line '$frame'.");
 }

 var uri = Uri.parse(match[1]);
 // If there's no scheme, this is a relative URI. We should interpret it as
 // relative to the current working directory.
 if (uri.scheme == '') {
   uri = path.toUri(path.absolute(path.fromUri(uri)));
 }

 var line = match[2] == null ? null : int.parse(match[2]);
 var column = match[3] == null ? null : int.parse(match[3]);
 return new Frame(uri, line, column, match[4]);
}
</pre>
</div>
</div>
<div class="method"><h4 id="parseIE">
<button class="show-code">Code</button>
factory <strong>Frame.parseIE</strong>(String frame) <a class="anchor-link" href="#parseIE"
              title="Permalink to Frame.Frame.parseIE">#</a></h4>
<div class="doc">
<p>Parses a string representation of an IE stack frame.</p>
<p>IE10+ frames look just like V8 frames. Prior to IE10, stack traces can't
be retrieved.</p>
<pre class="source">
factory Frame.parseIE(String frame) =&gt; new Frame.parseV8(frame);
</pre>
</div>
</div>
<div class="method"><h4 id="parseSafari6_0">
<button class="show-code">Code</button>
factory <strong>Frame.parseSafari6_0</strong>(String frame) <a class="anchor-link" href="#parseSafari6_0"
              title="Permalink to Frame.Frame.parseSafari6_0">#</a></h4>
<div class="doc">
<p>Parses a string representation of a Safari 6.0 stack frame.</p>
<p>Safari 6.0 frames look just like Firefox frames. Prior to Safari 6.0,
stack traces can't be retrieved.</p>
<pre class="source">
factory Frame.parseSafari6_0(String frame) =&gt; new Frame.parseFirefox(frame);
</pre>
</div>
</div>
<div class="method"><h4 id="parseSafari6_1">
<button class="show-code">Code</button>
factory <strong>Frame.parseSafari6_1</strong>(String frame) <a class="anchor-link" href="#parseSafari6_1"
              title="Permalink to Frame.Frame.parseSafari6_1">#</a></h4>
<div class="doc">
<p>Parses a string representation of a Safari 6.1+ stack frame.</p>
<pre class="source">
factory Frame.parseSafari6_1(String frame) {
 var match = _safariFrame.firstMatch(frame);
 if (match == null) {
   throw new FormatException(
       "Couldn't parse Safari stack trace line '$frame'.");
 }

 var uri = Uri.parse(match[2]);
 var member = match[1];
 if (member == null) member = '&lt;fn&gt;';
 var line = match[3] == '' ? null : int.parse(match[3]);
 var column = match[4] == '' ? null : int.parse(match[4]);
 return new Frame(uri, line, column, member);
}
</pre>
</div>
</div>
<div class="method"><h4 id="parseV8">
<button class="show-code">Code</button>
factory <strong>Frame.parseV8</strong>(String frame) <a class="anchor-link" href="#parseV8"
              title="Permalink to Frame.Frame.parseV8">#</a></h4>
<div class="doc">
<p>Parses a string representation of a Chrome/V8 stack frame.</p>
<pre class="source">
factory Frame.parseV8(String frame) {
 var match = _v8Frame.firstMatch(frame);
 if (match == null) {
   throw new FormatException("Couldn't parse V8 stack trace line '$frame'.");
 }

 // V8 stack frames can be in two forms.
 if (match[2] != null) {
   // The first form looks like " at FUNCTION (PATH:LINE:COL)". PATH is
   // usually an absolute URL, but it can be a path if the stack frame came
   // from d8.
   var uri = _uriOrPathToUri(match[2]);
   var member = match[1].replaceAll("&lt;anonymous&gt;", "&lt;fn&gt;");
   return new Frame(uri, int.parse(match[3]), int.parse(match[4]), member);
 } else {
   // The second form looks like " at PATH:LINE:COL", and is used for
   // anonymous functions. PATH is usually an absolute URL, but it can be a
   // path if the stack frame came from d8.
   var uri = _uriOrPathToUri(match[5]);
   return new Frame(uri, int.parse(match[6]), int.parse(match[7]), "&lt;fn&gt;");
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="parseVM">
<button class="show-code">Code</button>
factory <strong>Frame.parseVM</strong>(String frame) <a class="anchor-link" href="#parseVM"
              title="Permalink to Frame.Frame.parseVM">#</a></h4>
<div class="doc">
<p>Parses a string representation of a Dart VM stack frame.</p>
<pre class="source">
factory Frame.parseVM(String frame) {
 // The VM sometimes folds multiple stack frames together and replaces them
 // with "...".
 if (frame == '...') {
   return new Frame(new Uri(), null, null, '...');
 }

 var match = _vmFrame.firstMatch(frame);
 if (match == null) {
   throw new FormatException("Couldn't parse VM stack trace line '$frame'.");
 }

 // Get the pieces out of the regexp match. Function, URI and line should
 // always be found. The column is optional.
 var member = match[1].replaceAll("&lt;anonymous closure&gt;", "&lt;fn&gt;");
 var uri = Uri.parse(match[2]);
 // Work around issue 11901.
 if (uri == new Uri(path: 'timer_impl.dart')) {
   uri = Uri.parse('dart:async/timer_impl.dart');
 }
 var line = int.parse(match[3]);
 var column = null;
 var columnMatch = match[4];
 if (columnMatch != null) {
   column = int.parse(columnMatch);
 }
 return new Frame(uri, line, column, member);
}
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="column">
<button class="show-code">Code</button>
final int         <strong>column</strong> <a class="anchor-link"
            href="#column"
            title="Permalink to Frame.column">#</a>
        </h4>
        <div class="doc">
<p>The column number of the code location.</p>
<p>This can be null, indicating that the column number is unknown or
unimportant.</p>
<pre class="source">
final int column
</pre>
</div>
</div>
<div class="field"><h4 id="isCore">
<button class="show-code">Code</button>
final bool         <strong>isCore</strong> <a class="anchor-link"
            href="#isCore"
            title="Permalink to Frame.isCore">#</a>
        </h4>
        <div class="doc">
<p>Whether this stack frame comes from the Dart core libraries.</p>
<pre class="source">
bool get isCore =&gt; uri.scheme == 'dart';
</pre>
</div>
</div>
<div class="field"><h4 id="library">
<button class="show-code">Code</button>
final String         <strong>library</strong> <a class="anchor-link"
            href="#library"
            title="Permalink to Frame.library">#</a>
        </h4>
        <div class="doc">
<p>Returns a human-friendly description of the library that this stack frame
comes from.</p>
<p>This will usually be the string form of <a class="crossref" href="../frame/Frame.html#uri">uri</a>, but a relative URI will be
used if possible.</p>
<pre class="source">
String get library {
 if (uri.scheme != Uri.base.scheme) return uri.toString();
 if (path.style == path.Style.url) return path.relative(uri.toString());
 return path.relative(path.fromUri(uri));
}
</pre>
</div>
</div>
<div class="field"><h4 id="line">
<button class="show-code">Code</button>
final int         <strong>line</strong> <a class="anchor-link"
            href="#line"
            title="Permalink to Frame.line">#</a>
        </h4>
        <div class="doc">
<p>The line number on which the code location is located.</p>
<p>This can be null, indicating that the line number is unknown or
unimportant.</p>
<pre class="source">
final int line
</pre>
</div>
</div>
<div class="field"><h4 id="location">
<button class="show-code">Code</button>
final String         <strong>location</strong> <a class="anchor-link"
            href="#location"
            title="Permalink to Frame.location">#</a>
        </h4>
        <div class="doc">
<p>A human-friendly description of the code location.</p>
<pre class="source">
String get location {
 if (line == null) return library;
 if (column == null) return '$library $line';
 return '$library $line:$column';
}
</pre>
</div>
</div>
<div class="field"><h4 id="member">
<button class="show-code">Code</button>
final String         <strong>member</strong> <a class="anchor-link"
            href="#member"
            title="Permalink to Frame.member">#</a>
        </h4>
        <div class="doc">
<p>The name of the member in which the code location occurs.</p>
<p>Anonymous closures are represented as <code>&lt;fn&gt;</code> in this member string.</p>
<pre class="source">
final String member
</pre>
</div>
</div>
<div class="field"><h4 id="package">
<button class="show-code">Code</button>
final String         <strong>package</strong> <a class="anchor-link"
            href="#package"
            title="Permalink to Frame.package">#</a>
        </h4>
        <div class="doc">
<p>Returns the name of the package this stack frame comes from, or <code>null</code> if
this stack frame doesn't come from a <code>package:</code> URL.</p>
<pre class="source">
String get package {
 if (uri.scheme != 'package') return null;
 return uri.path.split('/').first;
}
</pre>
</div>
</div>
<div class="field"><h4 id="uri">
<button class="show-code">Code</button>
final Uri         <strong>uri</strong> <a class="anchor-link"
            href="#uri"
            title="Permalink to Frame.uri">#</a>
        </h4>
        <div class="doc">
<p>The URI of the file in which the code is located.</p>
<p>This URI will usually have the scheme <code>dart</code>, <code>file</code>, <code>http</code>, or <code>https</code>.</p>
<pre class="source">
final Uri uri
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="toString">
<button class="show-code">Code</button>
String <strong>toString</strong>() <a class="anchor-link" href="#toString"
              title="Permalink to Frame.toString">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Returns a string representation of this object.</p>
<div class="docs-inherited-from">docs inherited from Object </div></div>
<pre class="source">
String toString() =&gt; '$location in $member';
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          <div>This page was generated at 2014-02-10 17:46:59.846</div>
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
